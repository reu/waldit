# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `wal` gem.
# Please instead update this file by running `bin/tapioca gem wal`.


# source://wal//lib/wal/active_record_context_extension.rb#12
class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter < ::ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::Wal::ActiveRecordContextExtension

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#320
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#348
  def active?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#588
  def add_enum_value(type_name, value, **options); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#650
  def build_insert_sql(insert); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#669
  def check_version; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#343
  def connected?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#541
  def create_enum(name, values, **options); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
  def create_unlogged_tables; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
  def create_unlogged_tables=(_arg0); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
  def create_unlogged_tables?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
  def datetime_type; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
  def datetime_type=(_arg0); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
  def datetime_type?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
  def decode_dates; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
  def decode_dates=(_arg0); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
  def decode_dates?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#646
  def default_index_type?(index); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#486
  def disable_extension(name, force: T.unsafe(nil)); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#394
  def discard!; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#386
  def disconnect!; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#571
  def drop_enum(name, values = T.unsafe(nil), **options); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#473
  def enable_extension(name, **_arg1); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#518
  def enum_types; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#493
  def extension_available?(name); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#497
  def extension_enabled?(name); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#501
  def extensions; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#459
  def get_advisory_lock(lock_id); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#635
  def get_database_version; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#291
  def index_algorithms; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#620
  def max_identifier_length; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#400
  def native_database_types; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/abstract_adapter.rb#854
  def postgresql_version; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#466
  def release_advisory_lock(lock_id); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#359
  def reload_type_map; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#579
  def rename_enum(name, new_name = T.unsafe(nil), **options); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#606
  def rename_enum_value(type_name, **options); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#371
  def reset!; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#625
  def session_auth=(user); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#412
  def set_standard_conforming_strings; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#420
  def supports_advisory_locks?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#188
  def supports_bulk_alter?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#220
  def supports_check_constraints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#252
  def supports_comments?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#451
  def supports_common_table_expressions?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#244
  def supports_datetime_with_precision?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#416
  def supports_ddl_transactions?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#236
  def supports_deferrable_constraints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#224
  def supports_exclusion_constraints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#424
  def supports_explain?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#208
  def supports_expression_index?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#428
  def supports_extensions?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#216
  def supports_foreign_keys?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#436
  def supports_foreign_tables?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#279
  def supports_identity_columns?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#204
  def supports_index_include?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#192
  def supports_index_sort_order?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#268
  def supports_insert_conflict_target?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#268
  def supports_insert_on_conflict?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#268
  def supports_insert_on_duplicate_skip?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#268
  def supports_insert_on_duplicate_update?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#264
  def supports_insert_returning?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#248
  def supports_json?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#455
  def supports_lazy_transactions?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#432
  def supports_materialized_views?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#287
  def supports_native_partitioning?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#283
  def supports_nulls_not_distinct?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#444
  def supports_optimizer_hints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#200
  def supports_partial_index?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#196
  def supports_partitioned_indexes?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#440
  def supports_pgcrypto_uuid?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#260
  def supports_restart_db_transaction?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#256
  def supports_savepoints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#212
  def supports_transaction_isolation?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#228
  def supports_unique_constraints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#232
  def supports_validate_constraints?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#240
  def supports_views?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#275
  def supports_virtual_columns?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#630
  def use_insert_returning?; end

  private

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1112
  def add_pg_decoders; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1085
  def add_pg_encoders; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1051
  def arel_visitor; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1055
  def build_statement_pool; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1059
  def can_perform_case_insensitive_comparison_for?(column); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1034
  def column_definitions(table_name); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#956
  def configure_connection; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#938
  def connect; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1153
  def construct_coder(row, coder_class); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#781
  def extract_default_function(default_value, default); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#755
  def extract_value_from_default(default); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#854
  def get_oid_type(oid, fmod, column_name, sql_type = T.unsafe(nil)); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#785
  def has_default_function?(default_value, default); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#908
  def in_transaction?; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#744
  def initialize_type_map(m = T.unsafe(nil)); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#901
  def is_cached_plan_failure?(pgerror); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#867
  def load_additional_types(oids = T.unsafe(nil)); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#875
  def load_types_queries(initializer, oids); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#920
  def prepare_statement(sql, binds, conn); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#999
  def reconfigure_connection_timezone; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#944
  def reconnect; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#847
  def retryable_query_error?(exception); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#914
  def sql_key(sql); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#801
  def translate_exception(exception, message:, sql:, binds:); end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#742
  def type_map; end

  # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#1093
  def update_typemap_for_default_timezone; end

  class << self
    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
    def create_unlogged_tables; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
    def create_unlogged_tables=(value); end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#105
    def create_unlogged_tables?; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
    def datetime_type; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
    def datetime_type=(value); end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#123
    def datetime_type?; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#73
    def dbconsole(config, options = T.unsafe(nil)); end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
    def decode_dates; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
    def decode_dates=(value); end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#132
    def decode_dates?; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#676
    def initialize_type_map(m); end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#404
    def native_database_types; end

    # source://activerecord/8.0.2/lib/active_record/connection_adapters/postgresql_adapter.rb#57
    def new_client(conn_params); end

    private

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_create_unlogged_tables; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_create_unlogged_tables=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_datetime_type; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_datetime_type=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_decode_dates; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_decode_dates=(new_value); end
  end
end

# source://wal//lib/wal/watcher.rb#3
# typed: strong
module Wal; end

# source://wal//lib/wal/active_record_context_extension.rb#4
module Wal::ActiveRecordContextExtension
  # source://wal//lib/wal/active_record_context_extension.rb#5
  sig { params(context: T.untyped, prefix: T.untyped).returns(T.untyped) }
  def set_wal_watcher_context(context, prefix: T.unsafe(nil)); end
end

# source://wal//lib/wal.rb#26
class Wal::BeginTransactionEvent < ::T::Struct
  extend T::Sig

  const :transaction_id, ::Integer
  const :lsn, ::Integer
  const :final_lsn, ::Integer
  const :timestamp, ::Time

  # source://wal//lib/wal.rb#35
  sig { returns(::Integer) }
  def estimated_size; end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://wal//lib/wal.rb#47
module Wal::ChangeEvent
  extend T::Sig

  # source://wal//lib/wal.rb#61
  sig { params(attribute: T.any(::String, ::Symbol)).returns(T.untyped) }
  def attribute(attribute); end

  # source://wal//lib/wal.rb#68
  sig { params(attribute: T.any(::String, ::Symbol)).returns(T.nilable([T.untyped, T.untyped])) }
  def attribute_changes(attribute); end

  # source://wal//lib/wal.rb#73
  sig { params(attribute: T.any(::String, ::Symbol)).returns(T.untyped) }
  def attribute_was(attribute); end

  # source://wal//lib/wal.rb#56
  sig { params(attribute: T.any(::String, ::Symbol)).returns(T::Boolean) }
  def changed_attribute?(attribute); end

  # source://wal//lib/wal.rb#51
  sig { returns(T::Hash[::String, [T.untyped, T.untyped]]) }
  def diff; end
end

# source://wal//lib/wal.rb#40
class Wal::CommitTransactionEvent < ::T::Struct
  const :transaction_id, ::Integer
  const :lsn, ::Integer
  const :context, T::Hash[::String, T.untyped]
  const :timestamp, ::Time

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://wal//lib/wal.rb#117
class Wal::DeleteEvent < ::T::Struct
  include ::Wal::ChangeEvent
  extend T::Sig

  const :transaction_id, ::Integer
  const :lsn, ::Integer
  const :context, T::Hash[::String, T.untyped]
  const :table, ::String
  const :primary_key, T.untyped
  const :old, T::Hash[::String, T.untyped]

  # source://wal//lib/wal.rb#129
  sig { returns(T::Hash[::String, [T.untyped, T.untyped]]) }
  def diff; end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://wal//lib/wal.rb#16
Wal::Event = T.type_alias { T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent) }

# source://wal//lib/wal.rb#80
class Wal::InsertEvent < ::T::Struct
  include ::Wal::ChangeEvent
  extend T::Sig

  const :transaction_id, ::Integer
  const :lsn, ::Integer
  const :context, T::Hash[::String, T.untyped]
  const :table, ::String
  const :primary_key, T.untyped
  const :new, T::Hash[::String, T.untyped]

  # source://wal//lib/wal.rb#92
  sig { returns(T::Hash[::String, [T.untyped, T.untyped]]) }
  def diff; end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# A watcher that does nothing. Just for performance testing in general. Useful in testing aswell.
#
# source://wal//lib/wal/noop_watcher.rb#5
class Wal::NoopWatcher
  include ::Wal
  include ::Wal::Watcher
  include Wal::Watcher
  extend T::Sig

  # source://wal//lib/wal/noop_watcher.rb#10
  sig do
    override
      .params(
        event: T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)
      ).void
  end
  def on_event(event); end
end

# Watcher that process records at the end of a transaction, keeping only its final state.
#
# Example:
#
# ```ruby
# class InventoryAvailabilityWatcher < Wal::RecordWatcher
#   on_save Item, changed: %w[weight_unid_id] do |event|
#     recalculate_inventory_availability(event.primary_key)
#   end
#
#   on_save SalesOrder, changed: %w[status] do |event|
#     next unless event.attributes_changes(:status).one? "filled"
#
#     OrderItem
#       .where(sales_order_id: event.primary_key)
#       .pluck(:item_id)
#       .each { |item_id| recalculate_inventory_availability(item_id) }
#   end
#
#   on_save OrderItem, changed: %w[item_id weight_unit weight_unid_id] do |event|
#     if (old_item_id, new_item_id = event.attributes_changes("item_id"))
#       recalculate_inventory_availability(old_item_id)
#       recalculate_inventory_availability(new_item_id)
#     else
#       recalculate_inventory_availability(event.attribute(:item_id))
#     end
#   end
#
#   on_destroy OrderItem do |event|
#     recalculate_inventory_availability(event.attribute(:item_id))
#   end
#
#   def recalculate_inventory_availability(item_id)
#     ...
#   end
# end
# ```
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://wal//lib/wal/record_watcher.rb#41
class Wal::RecordWatcher
  include ::Wal
  include ::Wal::Watcher
  include Wal::Watcher
  extend T::Sig
  extend T::Helpers

  abstract!

  # `RecordWatcher` supports two processing strategies:
  #
  # `:memory`: Stores and aggregates records from a single transaction in memory. This has better performance but uses
  #  more memory, as at least one event for each record must be stored in memory until the end of a transaction
  #
  # `:temporary_table`: Offloads the record aggregation to a temporary table on the database. This is useful when you
  # are processing very large transactions that can't fit in memory. The tradeoff is obviously a worse performance.
  #
  # These strategies can be defined per transaction, and by default it will uses the memory one, and only fallback
  # to the temporary table if the transaction size is roughly 2 gigabytes or more.
  #
  # source://wal//lib/wal/record_watcher.rb#143
  sig { params(event: ::Wal::BeginTransactionEvent).returns(::Symbol) }
  def aggregation_strategy(event); end

  # source://wal//lib/wal/record_watcher.rb#152
  sig do
    override
      .params(
        event: T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)
      ).void
  end
  def on_event(event); end

  # source://wal//lib/wal/record_watcher.rb#102
  sig { params(event: T.any(::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)).void }
  def on_record_changed(event); end

  # source://wal//lib/wal/record_watcher.rb#128
  sig { params(table: ::String).returns(T::Boolean) }
  def should_watch_table?(table); end

  class << self
    # @private
    #
    # source://wal//lib/wal/record_watcher.rb#49
    sig { params(subclass: T.untyped).returns(T.untyped) }
    def inherited(subclass); end

    # source://wal//lib/wal/record_watcher.rb#96
    sig do
      params(
        table: T.any(::String, T.class_of(ActiveRecord::Base)),
        block: T.proc.bind(T.attached_class).params(event: ::Wal::DeleteEvent).void
      ).void
    end
    def on_destroy(table, &block); end

    # source://wal//lib/wal/record_watcher.rb#61
    sig do
      params(
        table: T.any(::String, T.class_of(ActiveRecord::Base)),
        block: T.proc.bind(T.attached_class).params(event: ::Wal::InsertEvent).void
      ).void
    end
    def on_insert(table, &block); end

    # source://wal//lib/wal/record_watcher.rb#85
    sig do
      params(
        table: T.any(::String, T.class_of(ActiveRecord::Base)),
        changed: T.nilable(T::Array[T.any(::String, ::Symbol)]),
        block: T.proc.bind(T.attached_class).params(event: T.any(::Wal::InsertEvent, ::Wal::UpdateEvent)).void
      ).void
    end
    def on_save(table, changed: T.unsafe(nil), &block); end

    # source://wal//lib/wal/record_watcher.rb#73
    sig do
      params(
        table: T.any(::String, T.class_of(ActiveRecord::Base)),
        changed: T.nilable(T::Array[T.any(::String, ::Symbol)]),
        block: T.proc.bind(T.attached_class).params(event: ::Wal::UpdateEvent).void
      ).void
    end
    def on_update(table, changed: T.unsafe(nil), &block); end
  end
end

# source://wal//lib/wal/record_watcher.rb#166
class Wal::RecordWatcher::MemoryRecordWatcher
  include ::Wal
  include ::Wal::Watcher
  include ::Wal::Watcher::SeparatedEvents
  include Wal::Watcher
  include Wal::Watcher::SeparatedEvents
  extend T::Sig
  extend T::Helpers

  # @return [MemoryRecordWatcher] a new instance of MemoryRecordWatcher
  #
  # source://wal//lib/wal/record_watcher.rb#175
  sig { params(watcher: T.untyped).void }
  def initialize(watcher); end

  # source://wal//lib/wal/record_watcher.rb#180
  sig { params(event: ::Wal::BeginTransactionEvent).void }
  def on_begin(event); end

  # source://wal//lib/wal/record_watcher.rb#184
  sig { params(_event: T.untyped).returns(T.untyped) }
  def on_commit(_event); end

  # source://wal//lib/wal/record_watcher.rb#221
  sig { params(event: ::Wal::DeleteEvent).void }
  def on_delete(event); end

  # source://wal//lib/wal/record_watcher.rb#192
  sig { params(event: ::Wal::InsertEvent).void }
  def on_insert(event); end

  # source://wal//lib/wal/record_watcher.rb#200
  sig { params(event: ::Wal::UpdateEvent).void }
  def on_update(event); end
end

# Records indexed by table and primary key
#
# source://wal//lib/wal/record_watcher.rb#173
Wal::RecordWatcher::MemoryRecordWatcher::RecordsStorage = T.type_alias { T::Hash[[::String, ::Integer], T.nilable(T.any(::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent))] }

# source://wal//lib/wal/record_watcher.rb#47
Wal::RecordWatcher::RecordEvent = T.type_alias { T.any(::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent) }

# source://wal//lib/wal/record_watcher.rb#242
class Wal::RecordWatcher::TemporaryTableRecordWatcher
  include ::Wal
  include ::Wal::Watcher
  include ::Wal::Watcher::SeparatedEvents
  include Wal::Watcher
  include Wal::Watcher::SeparatedEvents
  extend T::Sig
  extend T::Helpers

  # @return [TemporaryTableRecordWatcher] a new instance of TemporaryTableRecordWatcher
  #
  # source://wal//lib/wal/record_watcher.rb#253
  sig { params(watcher: T.untyped, batch_size: T.untyped).void }
  def initialize(watcher, batch_size: T.unsafe(nil)); end

  # source://wal//lib/wal/record_watcher.rb#251
  def base_active_record_class; end

  # source://wal//lib/wal/record_watcher.rb#251
  def base_active_record_class=(val); end

  # source://wal//lib/wal/record_watcher.rb#259
  sig { params(event: ::Wal::BeginTransactionEvent).void }
  def on_begin(event); end

  # source://wal//lib/wal/record_watcher.rb#308
  sig { params(_event: T.untyped).returns(T.untyped) }
  def on_commit(_event); end

  # source://wal//lib/wal/record_watcher.rb#330
  sig { params(event: ::Wal::DeleteEvent).void }
  def on_delete(event); end

  # source://wal//lib/wal/record_watcher.rb#320
  sig { params(event: ::Wal::InsertEvent).void }
  def on_insert(event); end

  # source://wal//lib/wal/record_watcher.rb#325
  sig { params(event: ::Wal::UpdateEvent).void }
  def on_update(event); end

  private

  # source://wal//lib/wal/record_watcher.rb#346
  sig { returns(T.class_of(ActiveRecord::Base)) }
  def base_class; end

  # source://wal//lib/wal/record_watcher.rb#370
  sig { params(persisted_event: T.untyped).returns(T.untyped) }
  def deserialize(persisted_event); end

  # source://wal//lib/wal/record_watcher.rb#350
  sig { params(event: T.untyped).returns(T.untyped) }
  def serialize(event); end

  class << self
    # source://wal//lib/wal/record_watcher.rb#251
    def base_active_record_class; end

    # source://wal//lib/wal/record_watcher.rb#251
    def base_active_record_class=(val); end
  end
end

# Responsible to hook into a Postgres logical replication slot and stream the changes to a specific `Watcher`.
# Also it supports inject "contexts" into the replication events.
#
# source://wal//lib/wal/replicator.rb#8
class Wal::Replicator
  include ::PG::Replication::Protocol
  include PG::Replication::Protocol
  extend T::Sig

  # source://wal//lib/wal/replicator.rb#19
  sig do
    params(
      replication_slot: ::String,
      use_temporary_slot: T::Boolean,
      db_config: T::Hash[::Symbol, T.untyped]
    ).void
  end
  def initialize(replication_slot:, use_temporary_slot: T.unsafe(nil), db_config: T.unsafe(nil)); end

  # source://wal//lib/wal/replicator.rb#38
  sig do
    params(
      watcher: ::Wal::Watcher,
      publications: T::Array[::String]
    ).returns(T::Enumerator::Lazy[T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)])
  end
  def replicate(watcher, publications:); end

  # source://wal//lib/wal/replicator.rb#30
  sig { params(watcher: ::Wal::Watcher, publications: T::Array[::String]).void }
  def replicate_forever(watcher, publications:); end
end

# source://wal//lib/wal/replicator.rb#165
class Wal::Replicator::Column < ::T::Struct
  const :name, ::String
  const :decoder, T.untyped

  # source://wal//lib/wal/replicator.rb#169
  sig { params(value: T.untyped).returns(T.untyped) }
  def decode(value); end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://wal//lib/wal/replicator.rb#174
class Wal::Replicator::Table < ::T::Struct
  const :name, ::String
  const :primary_key_colums, T::Array[::String]
  const :columns, T::Array[::Wal::Replicator::Column]

  # source://wal//lib/wal/replicator.rb#197
  sig { params(values: T.untyped).returns(T.untyped) }
  def decode_row(values); end

  # source://wal//lib/wal/replicator.rb#179
  sig { params(decoded_row: T.untyped).returns(T.untyped) }
  def primary_key(decoded_row); end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# A watcher that streams all the events of each WAL transaction on a separate thread.
#
# Useful to improve the throughput, as it will allow you to process events while fetching for more in parallel.
#
# Example:
#
# Watcher that persists all delete events as it arrives using a single database transaction, and without waiting
# for the full WAL log transaction to be finished.
#
# ```ruby
# class RegisterDeletesWalWatcher < Wal::StreamingWalWatcher
#   sig { override.params(events: T::Enumerator[Event]).void }
#   def on_transaction_events(events)
#     DeletedApplicationRecord.transaction do
#       events
#         .lazy
#         .filter { |event| event.is_a? DeleteEvent }
#         .each { |event| DeletedApplicationRecord.create_from_event(event) }
#     end
#   end
# end
# ```
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://wal//lib/wal/streaming_watcher.rb#26
class Wal::StreamingWatcher
  include ::Wal
  include ::Wal::Watcher
  include Wal::Watcher
  extend T::Sig
  extend T::Helpers

  abstract!

  # source://wal//lib/wal/streaming_watcher.rb#41
  sig do
    override
      .params(
        event: T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)
      ).void
  end
  def on_event(event); end

  # @abstract
  #
  # source://wal//lib/wal/streaming_watcher.rb#33
  sig do
    abstract
      .params(
        events: T::Enumerator[T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)]
      ).void
  end
  def on_transaction_events(events); end

  # source://wal//lib/wal/streaming_watcher.rb#36
  sig { params(event: ::Wal::BeginTransactionEvent).returns(::Integer) }
  def queue_size(event); end
end

# source://wal//lib/wal.rb#97
class Wal::UpdateEvent < ::T::Struct
  include ::Wal::ChangeEvent
  extend T::Sig

  const :transaction_id, ::Integer
  const :lsn, ::Integer
  const :context, T::Hash[::String, T.untyped]
  const :table, ::String
  const :primary_key, T.untyped
  const :old, T::Hash[::String, T.untyped]
  const :new, T::Hash[::String, T.untyped]

  # source://wal//lib/wal.rb#110
  sig { returns(T::Hash[::String, [T.untyped, T.untyped]]) }
  def diff; end

  class << self
    # source://sorbet-runtime/0.5.12210/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://wal//lib/wal/version.rb#5
Wal::VERSION = T.let(T.unsafe(nil), String)

# Watcher is the core API used to hook into Postgres WAL log.
# The only required method on the API is the `on_event`, which will receive a WAL entry of the following events:
# - Transaction started: `Wal::BeginTransactionEvent`
# - Row inserted: `Wal::InsertEvent`
# - Row updated: `Wal::UpdateEvent`
# - Row deleted: `Wal::DeleteEvent`
# - Transaction committed: `Wal::CommitTransactionEvent`
#
# The `on_event` method will be called without any buffering, so it is up to implementators to aggregate them if
# desired. In practice, it is rarelly useful to implement this module directly for application level business logic,
# and instead it is more recomended using more specific ones, such as the `RecordWatcher` and `StreamingWalWatcher`.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://wal//lib/wal/watcher.rb#15
module Wal::Watcher
  include ::Wal
  include Wal
  extend T::Sig
  extend T::Helpers

  abstract!

  # @abstract
  #
  # source://wal//lib/wal/watcher.rb#22
  sig do
    abstract
      .params(
        event: T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)
      ).void
  end
  def on_event(event); end

  # Allows dropping the processing of any table
  #
  # source://wal//lib/wal/watcher.rb#26
  sig { params(table: ::String).returns(T::Boolean) }
  def should_watch_table?(table); end

  # Check if the given context prefix should be allowed for this watcher
  #
  # source://wal//lib/wal/watcher.rb#32
  sig { params(prefix: ::String).returns(T::Boolean) }
  def valid_context_prefix?(prefix); end
end

# Include this module if you prefer to work with each event having its own method.
# This might be useful when you always want to process each type of event in a different way.
#
# Example:
#
# Watcher that calculates how much time passed between the begin and commit of a WAL transaction.
#
# ```ruby
# class MeasureTransactionTimeWatcher
#   extend T::Sig
#   include Wal::Watcher
#   include Wal::Watcher::SeparatedEvents
#
#   sig { params(event: BeginTransactionEvent).void }
#   def on_begin(event)
#     @start_time = Time.current
#   end
#
#   sig { params(event: CommitTransactionEvent).void }
#   def on_commit(event)
#     puts "Transaction processing time: #{Time.current - @start_time}"
#   end
# end
# ```
#
# source://wal//lib/wal/watcher.rb#60
module Wal::Watcher::SeparatedEvents
  extend T::Sig

  # source://wal//lib/wal/watcher.rb#80
  sig { params(event: ::Wal::BeginTransactionEvent).void }
  def on_begin(event); end

  # source://wal//lib/wal/watcher.rb#92
  sig { params(event: ::Wal::CommitTransactionEvent).void }
  def on_commit(event); end

  # source://wal//lib/wal/watcher.rb#89
  sig { params(event: ::Wal::DeleteEvent).void }
  def on_delete(event); end

  # source://wal//lib/wal/watcher.rb#64
  sig do
    params(
      event: T.any(::Wal::BeginTransactionEvent, ::Wal::CommitTransactionEvent, ::Wal::DeleteEvent, ::Wal::InsertEvent, ::Wal::UpdateEvent)
    ).void
  end
  def on_event(event); end

  # source://wal//lib/wal/watcher.rb#83
  sig { params(event: ::Wal::InsertEvent).void }
  def on_insert(event); end

  # source://wal//lib/wal/watcher.rb#86
  sig { params(event: ::Wal::UpdateEvent).void }
  def on_update(event); end
end
